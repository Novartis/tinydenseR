% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/landmarks.R
\name{get.landmarks}
\alias{get.landmarks}
\title{Identify landmarks via leverage score sampling}
\usage{
get.landmarks(
  .lm.obj,
  .verbose = TRUE,
  .seed = 123,
  .nHVG = 5000,
  .nPC = 30,
  .exc.vdj.mito.ribo.genes.from.hvg = TRUE,
  .force.in = NULL
)
}
\arguments{
\item{.lm.obj}{Object initialized with \code{setup.lm.obj}.}

\item{.verbose}{Logical, print progress messages. Default TRUE.}

\item{.seed}{Integer for reproducibility. Default 123.}

\item{.nHVG}{Integer, number of highly variable genes to select for RNA data.
Default 5000. Ignored for cytometry. Higher values capture more variation
but increase computation time.}

\item{.nPC}{Integer, number of principal components for dimensionality reduction.
Default 30. Must be less than the number of cells in smallest sample.}

\item{.exc.vdj.mito.ribo.genes.from.hvg}{Logical, whether to exclude V(D)J
recombination genes, mitochondrial genes (MT-), and ribosomal genes (RP)
from HVG selection (RNA only). Default TRUE. Recommended to avoid
technical/biological noise dominating variation.}

\item{.force.in}{Character vector of gene names to force into the feature set
regardless of variance (RNA only). Useful for known markers. Default NULL.}
}
\value{
Updated \code{.lm.obj} with populated fields:
\describe{
\item{\code{$raw.lm}}{Raw counts matrix for landmarks (landmarks × features)}
\item{\code{$lm}}{Processed landmark expression on selected features (landmarks × features):
\itemize{
\item RNA: PCA-reconstructed denoised expression (log2-scale after library size normalization)
\item Cytometry: Original marker values on selected markers
}
}
\item{\code{$scaled.lm}}{Z-scored landmark expression (landmarks × features, for visualization/heatmaps)}
\item{\code{$pca}}{List containing PCA results:
\itemize{
\item \code{$embed} - PC coordinates for landmarks (landmarks × PCs)
\item \code{$rotation} - Feature loadings (features × PCs)
\item \code{$center} - Feature means (length = # features)
\item \code{$scale} - Feature standard deviations (length = # features)
\item \code{$sdev} - Standard deviations of PCs (length = # PCs)
\item \code{$HVG} - Selected feature names (character vector)
}
If Harmony used: \code{$embed} and \code{$rotation} are Harmony-corrected/approximated
}
\item{\code{$harmony.obj}}{Symphony reference object (if \code{.harmony.var} specified), used for batch-corrected mapping of query cells}
}
}
\description{
Selects representative "landmark" cells from the full dataset using a two-pass
leverage score sampling strategy. Landmarks capture the representative cells
while being computationally tractable for downstream graph construction and mapping.
}
\details{
\strong{Two-pass landmark selection algorithm:}

\strong{Pass 1 - Initial sampling:}
\enumerate{
\item For RNA: normalize, log-transform, select top HVGs per sample
\item For cytometry: use specified markers
\item Compute sample-specific PCA
\item Calculate leverage scores (sum of squared PC loadings per cell)
\item Sample landmarks proportionally to leverage scores
}

\strong{Pass 2 - Refinement:}
\enumerate{
\item Pool landmarks from all samples
\item Compute dataset-wide PCA on pooled landmarks
\item Project ALL cells onto this shared PC space
\item Recalculate leverage scores using shared PCA
\item Resample landmarks with improved scores (final set)
}

This two-pass approach ensures landmarks are representative of global
(not just sample-specific) variation patterns. Leverage score sampling
prioritizes cells in high-variance regions while maintaining diversity.

\strong{Optional Harmony integration:}
If \code{.harmony.var} was specified in \code{setup.lm.obj}, performs
batch correction on landmark PC embeddings. This creates a reference
object for mapping query cells in a batch-corrected space.
}
\examples{
\dontrun{
# Typical workflow (from README)
lm.cells <- setup.lm.obj(.cells = .cells, .meta = .meta) |>
  get.landmarks(.nHVG = 500, .nPC = 3)

# RNA with more PCs and custom HVGs
lm.cells <- setup.lm.obj(.cells = .cells, .meta = .meta) |>
  get.landmarks(.nPC = 50, .nHVG = 3000)

# Force specific markers into feature set
lm.cells <- get.landmarks(lm.cells, 
                          .force.in = c("CD3D", "CD4", "CD8A"))
}
}
